#include"H.h"

constexpr int CONV_BIT(const char* z)
{
	//return (*z == '0') ? (1<<1) : 0;
	return (*z == '0') ? (1 << 1) : 0;
}
constexpr int BIT(const char* z)
{
	//return (*z == '\0') ? CONV_BIT(--z) :BIT(++z);
	int x = 0;
	while (*z != '\0')
	{
		if (*z == '1') { x = (x | 1); x = x << 1; }
		else if (*z == '0') { x = (x | 0); x = x << 1; }
		++z;
	}
	return x = x>>1;

}
constexpr int operator""_b(const char* x){	return BIT(x); };
constexpr int factorial(size_t x){	return (x) ? x * factorial(x - 1) : 1; }
string operator""_toBinStr(unsigned long long x) 
{ 
	string str{};
	int ost = 0;
	while (x != 1)
	{
		ost = x % 2;
		x = x / 2;
		str += (ost == 0) ? '0' : '1';
		
	}
	str += '1';
	reverse(str.begin(), str.end());
	return str;
};
template<typename T> class VEC
{ 
	T MAX;
	T MIN;
public:
	constexpr VEC(T x,T y):MIN(x),MAX(y){};
	constexpr T GET_MAX() const { return MAX; }
	constexpr T GET_MIN() const { return MIN; }
	constexpr int FIND_IN(T Z)
	{ 
		if (Z > MAX) return MAX;
		else if (Z < MIN) return MIN;
		else return Z;
	}
};
auto DELITER = [](auto x) { delete[] x; };

int main(){
	/* Задание 1 */
	/*
		Сырые строковые литералы (Raw String Literals)
		Выведите строку, например: my name is "Marina"
		а) без использования Raw String Literals
		б) посредством Raw String Literals
		в) добавьте разделители (Delimeter)
	*/
	{
		cout << "my name is \"Marina\"" << endl;
		cout << R"(my name is "Marina")" << endl;
		cout << R"qqq(my name is "Marina")qqq" << endl;
		NOP
		system("cls");
	}
	//////////////////////////////////////////////////////////////////////////////////////////////
	/*Задание 2*/
	/*
		Реализуйте вычисление факториала с помощью constexpr-функции.
	
		Подсказки/напоминания: 
				- constexpr – функция должна состоять из единственной инструкции return <выражение>; (пока!)
				- но это выражение может включать вызов другой constexpr – функции, в частности рекурсивный
				  вызов 
				- если параметр рекурсивной constexpr- функции - это константа, компилятор вычислит результат
				  на этапе компиляции

		Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции (если в качестве
						параметра используется константа, известная компилятору на этапе компиляции).
						Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
						посредством constexpr-функции:
	*/
	{	
		//Например:
		int ar[factorial(3)];
		NOP
		//или
		constexpr int n = factorial(5);
		int ar1[n];
		NOP
		//попробуйте:
		int m = 7;
		//constexpr int n1 = factorial(m);// Ошибка "не constexpr"
		//int ar1[n1];
		
		//а так?
		int n2 = factorial(m); //всё нормально
		NOP
		system("cls");
	}
	//////////////////////////////////////////////////////////////////////////////////////////////
	/* Задание 3a */ 
	/*
		Перевод с помощью пользовательского литерала из двоичного представления строкового в значение, например: 
		строку "100000000" -> в значение 256
		Проверить результат посредством префикса 0b
		Чтобы вызов пользовательского литерала выглядел просто и читаемо, например: 100000000_b	логично использовать пользовательский 
		литерал с единственным параметром - const char*

		Так как речь идет о литералах, логично вычислять значения на этапе компиляции
		=> реализуйте пользовательский литерал посредством constexpr - функций
		Подсказка/напоминание: 
				- constexpr – функция должна состоять из единственной инструкции return <выражение>;
				- но это выражение может включать вызов другой constexpr – функции,
				- которая может быть рекурсивной (если параметр такой функции - это константа, компилятор вычислит результат вызова рекурсивной функции на этапе компиляции)
	*/
	{
		//int y = "123"_b;//<---почему так нельзя???
		size_t X = 0b100000000;
		size_t Z = 100000000_b;
		NOP
		system("cls");
	}
	/*Задание 3b */
	/*
		Перевод в строковое двоичное представление, например: 256 -> "0b100000000" 
		Так как строка может быть любой длины, логичнее и проще возвращать объект std::string => возвращаемое значение не может быть constexpr!
		Подсказка: манипулятора std::bin пока нет => преобразование в двоичную строку придется делать вручную
		Подсказка: количество разрядов в байте определяет константа CHAR_BIT - <cstdint>
	*/
	{
		string sBin = 256_toBinStr;
		NOP
		system("cls");
	}
	//////////////////////////////////////////////////////////////////////////////////////////////
	/* Задание 4а */
	/*
		constexpr - объекты 
		Создать класс (шаблон класса?) для хранения и манипулирования диапазоном значений.
		В классе должны быть:
			переменные для хранения минимального и максимального значений,
			методы для получения каждого из значений 
			метод, который получает любое значение данного типа и формирует результирующее значение:
									если принадлежит диапазону, то его и возвращаем
									если меньше минимального значения, возвращаем минимальное
									если больше максимального значения, возвращаем максимальное

		Проверьте тот факт, что компилятор вычисляет значение на этапе компиляции. 
						Для проверки достаточно создать встроенный массив с размерностью, вычисляемой
						посредством constexpr-метода:
	*/
	{
		constexpr VEC<int> Z(1,5);
		int U[Z.GET_MAX()];
		NOP
	}	
	//////////////////////////////////////////////////////////////////////////////////////////////
	/* Задание 5 */ /*- unique_ptr*/
	{
		/* 5.а - обеспечьте корректное выполнение фрагмента */
		{
			std::vector<std::string*> v = { new std::string("aa"), new std::string("bb"), new std::string("cc") };
			/* Распечатайте все строки */
			for (string* x : v)	{ cout << *x << endl; }
			NOP
			system("cls");
			for (string* x : v) { delete x; }
		}// ----------------------->>> Утечка памяти!!!!
		/* 5.b - модифицируйте задание 5.а: */
		/*
			обеспечьте посредством std::unique_ptr: 
			эффективное заполнение (вспомните про разные способы формирования std::unique_ptr), безопасное хранение 
			указателей на динамически создаваемые объекты std::string, манипулирование, и освобождение ресурсов
		*/	
		{
		 //Распечатайте все строки	
			vector<unique_ptr<string>> v;
			v.push_back(make_unique<string>("aa"));
			v.push_back(make_unique<string>("bb"));
			v.push_back(make_unique<string>("cc"));
			for (unique_ptr<string> &x : v) { cout << *x.get() << endl; }
			NOP
			system("cls");
		 //??? Уничтожение динамически созданных объектов?
		} //???
		/* 5.c - дополните задание 5.b */
		/*
			добавьте возможность изменять хранящиеся строки	следующим образом (например, добавить указанный суффикс: "AAA" -> "AAA_1")  
		*/
		{
			string str{ "_1" };
			vector<unique_ptr<string>> v;
			v.push_back(make_unique<string>("aa"));
			v.push_back(make_unique<string>("bb"));
			v.push_back(make_unique<string>("cc"));
			for (unique_ptr<string> &x : v) { *x+=str; cout << *x.get() << endl; }
			NOP
			system("cls");
		}
		/* 5.d - динамический массив объектов */	
		/*
			Создайте unique_ptr, который является оберткой для динамического массива с элементами std::string.
			С помощью unique_ptr::operator[] заполните обернутый массив значениями.	Когда происходит освобождения памяти?
		*/
		{
			unique_ptr<string[]> UPT_M = make_unique<string[]>(2);
			UPT_M[0] = move("qwe");
			NOP
			system("cls");
		}//Уничтожение динамически созданных объектов	
		/* 5.e - массивы динамических объектов и пользовательская delete-функция (функтор) */
		/*
			Задан стековый массив указателей на динамически созданные объекты. 
			Создайте unique_ptr для такого массива.
			Реализуйте пользовательскую delete-функцию (функтор) для корректного освобождения памяти.
		 */
		{
			std::string* arStrPtr[] = { new std::string("aa"), new std::string("bb"), new std::string("cc") };
			//unique_ptr < string[]> UPT_MM = make_unique<string[]>(3);
			unique_ptr < string[],decltype(DELITER)> UPT_M(new  string[3], DELITER);
			UPT_M[0] = move(*arStrPtr[0]);
			UPT_M[1] = move(*arStrPtr[1]);
			UPT_M[2] = move(*arStrPtr[2]);
			cout << UPT_M[2];
			NOP
			system("cls");
		}
		/* 5.f Создайте и заполните вектор, содержащий unique_ptr для указателей на std::string */
		/*
			Посредством алгоритмя copy() скопируйте элементы вектора в пустой список с элементами того же типа.
			Подсказка: перемещающие итераторы и шаблон std::make_move_iterator
		*/
		{
			vector<unique_ptr<string>> v;
			v.push_back(make_unique<string>("aa"));
			v.push_back(make_unique<string>("bb"));
			v.push_back(make_unique<string>("cc"));

			list<unique_ptr<string>> ls(3);
			copy(make_move_iterator(v.begin()), make_move_iterator(v.end()),front_inserter(ls));
			NOP
			system("cls");
		}		
	}
	////////////////////////////////////////////////////////////////////////////////
	/* Задание 6.shared_ptr + пользовательская delete-функция */
	/*
		Реализовать возможность записи в файл данных (строчек) из разных источников
		(для упрощения пусть источниками являются два массива).
		Так как все "писатели" будут по очереди записывать свои данные в один и тот же файл,
		логично предоставить им возможность пользоваться одним и тем же указателем FILE* =>
		безопасной оберткой для такого указателя является shared_ptr
		а. Первый владелец должен открыть/создать файл для записи
		б. Все остальные писатели должны присоединиться к использованию
		в. Последний владелец указателя должен закрыть файл
		Подсказка: имитировать порядок записи можно с помощью функции rand() 
	*/
	{
		//"писатели":
		//Создать writer1, writer2
		//например, источники данных:
		char ar1[] = "Writer1 ";
		char ar2[] = "Writer2 ";

		//FILE* fpp = fopen("test.txt", "w");
		//fputs(ar1, fpp);

		shared_ptr<FILE> fp(fopen("T.txt", "w"), [](FILE* pf) {fclose(pf); });
		shared_ptr<FILE> fp2(fp);
		NOP
		//заданное число итераций случайным образом позволяем одному из "писателей" записать в файл свою строчку
		//Подсказка: строчки удобно записывать в файл посредством функции fputs()

			for (int i = 1; i < 5; i++)
			{
				size_t RND = (rand())%2;
				if (++RND == 1) { fputs(ar1, &(*fp));}
				else { fputs(ar2, &(*fp)); }
				NOP
			}
  		NOP
	}//закрытие файла???
	NOP
}